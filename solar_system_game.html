<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>太阳系模拟游戏</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: #fff;
        font-family: Arial, sans-serif;
      }

      canvas {
        display: block;
      }

      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
      }

      #timer {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
      }

      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        display: none;
      }

      button {
        background-color: #4caf50;
        border: none;
        color: white;
        padding: 10px 15px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <p>太阳系模拟游戏 1.5.3</p>
      <p>长按鼠标左键可以生成引力场</p>
      <p>长按鼠标右键可以生成斥力场<br />在星体上右键可以引爆</p>
      <div>
        <label for="gravityStrength">引力强度: </label>
        <input
          type="range"
          id="gravityStrength"
          min="1"
          max="1000"
          value="50"
        />
        <span id="gravityValue">50</span>
      </div>
      <div>
        <label for="spawnSpeed">物质生成速度: </label>
        <input type="range" id="spawnSpeed" min="1" max="800" value="20" />
        <span id="spawnSpeedValue">20</span>
      </div>
      <div id="stats">
        <p>星体数量: <span id="bodyCount">1</span></p>
        <p>最大行星: <span id="largestPlanet">无</span></p>
        <p>历史总星体数量: <span id="totalBodyCount">1</span></p>
      </div>
    </div>
    <div id="timer">
      <p>游戏时间: <span id="gameTime">00:00</span></p>
    </div>
    <div id="gameOver">
      <h1>游戏结束</h1>
      <p>太阳已经超新星爆发，摧毁了整个太阳系！</p>
      <button id="restartButton">重新开始</button>
    </div>
    <script>
      // 游戏常量
      const GAME_DURATION = 10 * 60; // 10分钟，以秒为单位
      const SUN_EXPANSION_TIME = 0.6 * GAME_DURATION;
      const RED_GIANT_TIME = 0.9 * GAME_DURATION;
      const SUN_SHRINK_TIME = 10;
      const SUN_EXPLODE_TIME = 10;
      const SUN_BEFORE_EXPLODE_TIME = 3;
      const SUN_DEATH_TIME =
        GAME_DURATION -
        (SUN_BEFORE_EXPLODE_TIME + SUN_EXPLODE_TIME + SUN_SHRINK_TIME);
      // 天体类型阈值（质量）
      const ASTEROID_THRESHOLD = 16;
      const DWARF_PLANET_THRESHOLD = 64;
      const PLANET_THRESHOLD = 200;
      const MAX_OBJECTS = 3000;
      const GAS_GIANT_THRESHOLD = 500;
      const TIME_SCALE = 4.0;
      const G = 10;
      const PLAYER_G_BONUS = 1000;
      const SUN_MASS = 3200;
      const SCALE_FACTOR = 1.5;
      const MERGE_MASS_INITIAL_SCALER_FACTOR = 0.75;
      const MERGE_MASS_HALF_THRESHOLD = 400;
      const RADIUS_FACTOR = 0.26;
      const PURGE_DISTANCE = 2000;
      const MIN_ACCELERATION_DIFF = 0.02;

      let mergeScaler = createSpecialFunction(
        MERGE_MASS_HALF_THRESHOLD,
        MERGE_MASS_INITIAL_SCALER_FACTOR
      );
      // 游戏状态
      let gameTime = 0;
      let gameRunning = true;
      let scale = 1.0;
      let bodies = [];
      let matter = [];
      let mouseX = 0;
      let mouseY = 0;
      let mouseDown = false;
      let rightMouseDown = false;
      let gravityStrength = 50;
      let bodyIdCounter = 1;
      let spawnSpeedFactor = 20; // 初始速度因子
      let lastMatterSpawn = 0;
      let baseSpawnInterval = 60; // 基础生成间隔（毫秒），对应1x速度
      let explosions = [];

      const englishPlanetNames = [
        "Nexus",
        "Astralis",
        "Chronos",
        "Zephyria",
        "Oblivion",
        "Elysium",
        "Novaris",
        "Celestia",
        "Proxima",
        "Vortex",
        "Helios",
        "Solstice",
        "Nebula",
        "Andromis",
        "Polaris",
        "Astrid",
        "Lumina",
        "Zenith",
        "Orion",
        "Thalassa",
        "Aether",
        "Cryonis",
        "Thermos",
        "Antares",
        "Meridian",
        "Callisto",
        "Hyperion",
        "Lyra",
        "Noctis",
        "Eternis",
        "Tempest",
        "Avalon",
        "Nimbus",
        "Quantum",
        "Vega",
        "Altair",
        "Sirius",
        "Rigel",
        "Arcturus",
        "Cassini",
        "Kepler",
        "Galileo",
        "Hubble",
        "Newton",
        "Hawking",
        "Sagan",
        "Tycho",
        "Copernicus",
        "Halley",
        "Azura",
        "Cygnus",
        "Draco",
        "Eridanus",
        "Fornax",
        "Gemini",
        "Hydra",
        "Indus",
        "Lacerta",
        "Mensa",
        "Norma",
        "Octans",
        "Pavo",
        "Reticulum",
        "Sculptor",
        "Tucana",
        "Volans",
        "Phoenix",
        "Aquila",
        "Boötes",
        "Corona",
        "Delphinus",
        "Equuleus",
        "Hercules",
        "Lupus",
        "Lynx",
        "Pegasus",
        "Perseus",
        "Sagitta",
        "Triangulum",
        "Vulpecula",
        "Caelum",
        "Circinus",
        "Columba",
        "Crater",
        "Corvus",
        "Pyxis",
        "Sextans",
        "Telescopium",
        "Microscopium",
        "Monoceros",
        "Musca",
        "Auriga",
        "Camelopardalis",
        "Carina",
        "Centaurus",
        "Cepheus",
        "Cetus",
        "Chamaeleon",
        "Dorado",
        "Grus",
        "Horologium",
        "Hydrus",
        "Lacerta",
        "Lepus",
        "Libra",
        "Pictor",
        "Asteria",
        "Caelestis",
        "Luminos",
        "Stellaris",
        "Eos",
        "Nyx",
        "Selene",
        "Titania",
        "Oberon",
        "Umbra",
        "Solara",
        "Lunaris",
        "Cosmica",
        "Galaxia",
        "Novarum",
        "Auroris",
        "Borealis",
        "Eclipsis",
        "Quasar",
        "Pulsar",
        "Neutron",
        "Magnetar",
        "Photonis",
        "Graviton",
        "Parallax",
        "Apogee",
        "Perigee",
        "Aphelion",
        "Perihelion",
        "Equinox",
        "Terminus",
        "Horizon",
        "Infinitum",
        "Cosmos",
        "Astrum",
        "Sidus",
        "Meteora",
        "Cometa",
        "Asteroidea",
        "Planetar",
        "Dwarfis",
        "Gigantica",
        "Supernova",
        "Athena",
        "Apollo",
        "Artemis",
        "Poseidon",
        "Hermes",
        "Hephaestus",
        "Demeter",
        "Hestia",
        "Ares",
        "Aphrodite",
        "Hades",
        "Persephone",
        "Dionysus",
        "Morpheus",
        "Hypnos",
        "Thanatos",
        "Erebus",
        "Hemera",
        "Aion",
        "Chronus",
        "Gaia",
        "Uranus",
        "Oceanus",
        "Tethys",
        "Rhea",
        "Theia",
        "Phoebe",
        "Mnemosyne",
        "Themis",
        "Iapetus",
        "Coeus",
        "Crius",
        "Hyperion",
        "Thalia",
        "Calliope",
        "Clio",
        "Erato",
        "Euterpe",
        "Melpomene",
        "Polyhymnia",
        "Terpsichore",
        "Urania",
        "Asclepius",
        "Eirene",
        "Harmonia",
        "Nemesis",
        "Nike",
        "Tyche",
        "Zephyrus",
        "Notus",
        "Boreas",
        "Eurus",
      ];

      function createSpecialFunction(t, initial) {
        // 常数计算
        const ln2 = Math.log(2);
        const factor = t / ln2;

        return function (x) {
          return Math.exp(-(ln2 / t) * x) * initial;
        };
      }

      // 获取Canvas和上下文
      const canvas = document.getElementById("gameCanvas");
      const gl = canvas.getContext("webgl");
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      if (!gl) {
        alert("无法初始化WebGL，您的浏览器可能不支持。");
      }
      // 设置Canvas大小
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      // 着色器程序
      const vsSource = `
      attribute vec2 aPosition;
      attribute float aSize;
      attribute vec4 aColor;
      
      uniform float uScale;
      uniform vec2 uCenter;
      uniform vec2 uResolution;
      
      varying vec4 vColor;
      
      void main() {
        vec2 position = (aPosition - uCenter) * uScale;
        vec2 zeroToOne = position / uResolution + 0.5;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        gl_PointSize = aSize * uScale;
        vColor = aColor;
      }
    `;
      const fsSource = `
      precision mediump float;
      varying vec4 vColor;
      
      void main() {
        float dist = distance(gl_PointCoord, vec2(0.5, 0.5));
        if (dist > 0.5) {
          discard;
        }
        gl_FragColor = vColor;
      }
    `;
      // 创建着色器程序
      function createShaderProgram(vs, fs) {
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vs);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
          console.error(
            "顶点着色器编译错误:",
            gl.getShaderInfoLog(vertexShader)
          );
          return null;
        }
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fs);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
          console.error(
            "片段着色器编译错误:",
            gl.getShaderInfoLog(fragmentShader)
          );
          return null;
        }
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error("着色器程序链接错误:", gl.getProgramInfoLog(program));
          return null;
        }
        return program;
      }
      const shaderProgram = createShaderProgram(vsSource, fsSource);
      // 获取着色器变量位置
      const programInfo = {
        attribLocations: {
          position: gl.getAttribLocation(shaderProgram, "aPosition"),
          size: gl.getAttribLocation(shaderProgram, "aSize"),
          color: gl.getAttribLocation(shaderProgram, "aColor"),
        },
        uniformLocations: {
          scale: gl.getUniformLocation(shaderProgram, "uScale"),
          center: gl.getUniformLocation(shaderProgram, "uCenter"),
          resolution: gl.getUniformLocation(shaderProgram, "uResolution"),
        },
      };
      // 天体类
      class CelestialBody {
        constructor(x, y, vx, vy, mass, color, name, type) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.mass = mass;
          this.radius = Math.pow(mass, RADIUS_FACTOR) * SCALE_FACTOR;
          this.color = color;
          this.name = name;
          this.trail = [];
          this.lastTrailTime = Date.now();
          this.type = type;
          this.createTime = Date.now();
          this.isFragment = false;
        }
        updatePosition(dt) {
          this.x += this.vx * dt;
          this.y += this.vy * dt;
        }
        update(dt) {
          // 更新位置
          if (this.type != "sun") {
            this.updatePosition(dt)
          }

          // 只为非星际物质的天体记录轨迹
          if (this.type !== "星际物质" && this.type != "sun") {
            // 每隔一定时间添加一个轨迹点
            const now = Date.now();

            const recordInterval = 50;

            if (now - this.lastTrailTime > recordInterval) {
              this.trail.push({
                x: this.x,
                y: this.y,
                time: now,
              });
              this.lastTrailTime = now;

              // 根据天体质量计算轨迹保留时间（1-5秒）
              let trailDuration = 1000;
              if (this.mass >= DWARF_PLANET_THRESHOLD) {
                trailDuration = 3000;
              }
              if (this.mass >= PLANET_THRESHOLD) {
                trailDuration = 6000;
              }
              if (this.mass >= GAS_GIANT_THRESHOLD) {
                trailDuration = 12000;
              }

              // 删除超过保留时间的轨迹点
              const cutoffTime = now - trailDuration;
              while (this.trail.length > 0 && this.trail[0].time < cutoffTime) {
                this.trail.shift();
              }
            }
          }
        }
        canBeAffected() {
          if (this.isFragment == true && Date.now() - this.createTime < 500) {
            return false;
          }
          return true;
        }
        applyGravity(body, dt) {
          if (!this.canBeAffected() || !body.canBeAffected()) {
            return false;
          }
          const dx = body.x - this.x;
          const dy = body.y - this.y;
          const distSq = dx * dx + dy * dy;
          const dist = Math.sqrt(distSq);
          if (dist < this.radius + body.radius) {
            return true; // 发生碰撞
          }

          // 引力计算 F = G * m1 * m2 / r^2
          const force = (G * this.mass * body.mass) / distSq;
          // 应用力
          const angle = Math.atan2(dy, dx);
          const fx = Math.cos(angle) * force;
          const fy = Math.sin(angle) * force;
          // 加速度 a = F / m
          const ax = fx / this.mass;
          const ay = fy / this.mass;
          if (body.type == 'sun' || Math.sqrt(Math.pow(ax, 2), Math.pow(ay, 2) >= MIN_ACCELERATION_DIFF)) {
          // 更新速度
            this.vx += ax * dt;
            this.vy += ay * dt;
          }
          return false;
        }
        applyPlayerGravity(x, y, strength, isRepulsive, dt) {
          if (this.type == "sun") {
            return;
          }
          const dx = x - this.x;
          const dy = y - this.y;
          const distSq = dx * dx + dy * dy;
          const dist = Math.sqrt(distSq);
          if (dist < 20) return; // 太近不应用力
          if (dist > 5000) return; // 太远不应用力
          // 引力计算
          const grav = (G * PLAYER_G_BONUS * strength) / 50;
          const force = (grav * this.mass) / distSq;
          // 应用力
          const angle = Math.atan2(dy, dx);
          const fx = Math.cos(angle) * force * (isRepulsive ? -1 : 1);
          const fy = Math.sin(angle) * force * (isRepulsive ? -1 : 1);
          // 加速度
          const ax = fx / this.mass;
          const ay = fy / this.mass;
          if (Math.sqrt(Math.pow(ax, 2), Math.pow(ay, 2) >= MIN_ACCELERATION_DIFF)) {
            // 更新速度
            this.vx += ax * dt;
            this.vy += ay * dt;
          }
        }
        getType() {
          if (this.type === "sun") return "太阳";
          if (this.mass < ASTEROID_THRESHOLD) {
            return "星际物质";
          } else if (this.mass < DWARF_PLANET_THRESHOLD) {
            return "小行星";
          } else if (this.mass < PLANET_THRESHOLD) {
            return "矮行星";
          } else if (this.mass < GAS_GIANT_THRESHOLD) {
            return "行星";
          } else {
            return "巨行星";
          }
        }
        updateTypeAndName() {
          const oldType = this.type;
          const newType = this.getType();
          let items = englishPlanetNames;
          if (oldType !== newType && newType !== "星际物质") {
            if (oldType === "星际物质") {
              bodyIdCounter++;
              this.name = items[Math.floor(Math.random() * items.length)];
            } else {
              this.name = this.name;
            }
            this.type = newType;
          }
        }
        split() {
          if (this.mass <= 3) return [this]; // 太小无法分裂
          const pieces = Math.floor(Math.random() * 6) + 2; // 2-8个碎片
          const fragments = [];
          let remainingMass = this.mass * 0.8; // 总质量损失20%
          for (let i = 0; i < pieces; i++) {
            // 最后一个碎片获得剩余所有质量
            let fragMass;
            if (i === pieces - 1) {
              fragMass = remainingMass;
            } else {
              fragMass = remainingMass * (Math.random() * 0.5 + 0.1); // 获得10%-60%的剩余质量
              remainingMass -= fragMass;
            }
            // 随机速度方向
            const angle = Math.random() * Math.PI * 2;
            const speed =
              Math.sqrt(this.vx * this.vx + this.vy * this.vy) +
              Math.random() * 15 +
              10;
            const vx = this.vx * 0.5 + Math.cos(angle) * speed * 0.5;
            const vy = this.vy * 0.5 + Math.sin(angle) * speed * 0.5;
            // 随机颜色变化
            const colorVariation = 0.2;
            const color = [
              Math.max(
                0,
                Math.min(
                  1,
                  this.color[0] + (Math.random() - 0.5) * colorVariation
                )
              ),
              Math.max(
                0,
                Math.min(
                  1,
                  this.color[1] + (Math.random() - 0.5) * colorVariation
                )
              ),
              Math.max(
                0,
                Math.min(
                  1,
                  this.color[2] + (Math.random() - 0.5) * colorVariation
                )
              ),
            ];
            // 位置略微偏移
            const offset = this.radius * 0.5;
            const x = this.x + (Math.random() - 0.5) * offset;
            const y = this.y + (Math.random() - 0.5) * offset;
            const fragment = new CelestialBody(
              x,
              y,
              vx,
              vy,
              fragMass,
              color,
              "",
              "星际物质"
            );
            fragment.isFragment = true;
            fragment.updateTypeAndName();
            fragments.push(fragment);
          }
          return fragments;
        }
      }
      // 爆炸效果类
      class Explosion {
        constructor(x, y, color, maxRadius) {
          this.x = x;
          this.y = y;
          this.color = color;
          this.maxRadius = maxRadius * 3; // 最大半径是原始天体的3倍
          this.currentRadius = 0;
          this.alpha = 1.0;
          this.duration = 1.5; // 爆炸持续1.5秒
          this.elapsed = 0;
        }

        update(dt) {
          this.elapsed += dt;
          const progress = Math.min(this.elapsed / this.duration, 1.0);
          this.currentRadius = this.maxRadius * progress;
          this.alpha = 1.0 - progress;
          return progress < 1.0; // 返回false表示爆炸已结束
        }

        draw(ctx) {
          const screenX = (this.x - sun.x) * scale + ctx.canvas.width / 2;
          const screenY = (this.y - sun.y) * scale + ctx.canvas.height / 2;

          ctx.beginPath();
          ctx.arc(screenX, screenY, this.currentRadius * scale, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${Math.floor(
            this.color[0] * 255
          )}, ${Math.floor(this.color[1] * 255)}, ${Math.floor(
            this.color[2] * 255
          )}, ${this.alpha})`;
          ctx.fill();
        }
      }
      // 创建太阳 - 修复后的代码
      const sun = new CelestialBody(
        0,
        0,
        0,
        0,
        SUN_MASS,
        [1.0, 0.9, 0.0], // 黄色
        "太阳",
        "sun"
      );
      bodies.push(sun);
      // 缓冲区数据
      function createBuffers() {
        // 位置缓冲区
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // 大小缓冲区
        const sizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
        // 颜色缓冲区
        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        return {
          position: positionBuffer,
          size: sizeBuffer,
          color: colorBuffer,
        };
      }
      const buffers = createBuffers();
      // 更新缓冲区数据
      function updateBuffers() {
        const allBodies = [...bodies, ...matter];
        const positions = new Float32Array(allBodies.length * 2);
        const sizes = new Float32Array(allBodies.length);
        const colors = new Float32Array(allBodies.length * 4); // 修改为4个通道 (RGBA)

        for (let i = 0; i < allBodies.length; i++) {
          const body = allBodies[i];
          positions[i * 2] = body.x;
          positions[i * 2 + 1] = body.y;
          sizes[i] = body.radius * 2;

          // 处理颜色数组 - 支持透明度
          colors[i * 4] = body.color[0]; // R
          colors[i * 4 + 1] = body.color[1]; // G
          colors[i * 4 + 2] = body.color[2]; // B

          // 如果颜色数组有第四个元素(Alpha)，则使用它，否则默认为1.0(完全不透明)
          colors[i * 4 + 3] = body.color.length >= 4 ? body.color[3] : 1.0; // A
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.size);
        gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        return allBodies.length;
      }
      // 绘制场景
      function drawScene(count) {
        gl.clearColor(0.0, 0.0, 0.05, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(shaderProgram);
        // 设置缓冲区
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(
          programInfo.attribLocations.position,
          2,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.position);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.size);
        gl.vertexAttribPointer(
          programInfo.attribLocations.size,
          1,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.size);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
        gl.vertexAttribPointer(
          programInfo.attribLocations.color,
          4,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.color);
        // 设置uniform变量
        gl.uniform1f(programInfo.uniformLocations.scale, scale);
        gl.uniform2f(programInfo.uniformLocations.center, sun.x, sun.y);
        gl.uniform2f(
          programInfo.uniformLocations.resolution,
          canvas.width,
          canvas.height
        );
        // 绘制点
        gl.drawArrays(gl.POINTS, 0, count);
        // 绘制轨迹
        drawTrails();
        drawExplosions();
        // 绘制名称标签
        drawLabels();
      }
      // 创建一个单独的2D canvas用于绘制标签
      const labelCanvas = document.createElement("canvas");
      labelCanvas.width = canvas.width;
      labelCanvas.height = canvas.height;
      labelCanvas.style.position = "absolute";
      labelCanvas.style.top = "0";
      labelCanvas.style.left = "0";
      labelCanvas.style.pointerEvents = "none"; // 让鼠标事件穿透到下层canvas
      document.body.appendChild(labelCanvas);
      // 使用单独的Canvas 2D上下文绘制标签
      function drawLabels() {
        const ctx = labelCanvas.getContext("2d");
        // 清除之前的标签
        ctx.clearRect(0, 0, labelCanvas.width, labelCanvas.height);
        ctx.font = "12px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        for (const body of bodies) {
          if (body.type !== "sun" && body.type !== "星际物质") {
            const screenX = (body.x - sun.x) * scale + labelCanvas.width / 2;
            const screenY = (body.y - sun.y) * scale + labelCanvas.height / 2;
            ctx.fillText(
              body.name + ` (${body.type})`,
              screenX,
              screenY - body.radius * scale - 5
            );
          }
        }
      }
      function drawExplosions() {
        const ctx = explosionCanvas.getContext("2d");
        ctx.clearRect(0, 0, explosionCanvas.width, explosionCanvas.height);

        // 更新和绘制所有爆炸效果
        for (let i = explosions.length - 1; i >= 0; i--) {
          const explosion = explosions[i];
          const isActive = explosion.update(1 / 60); // 假设60fps

          if (isActive) {
            explosion.draw(ctx);
          } else {
            explosions.splice(i, 1); // 移除已完成的爆炸效果
          }
        }
      }
      // 修改绘制轨迹的函数
      function drawTrails() {
        const ctx = trailCanvas.getContext("2d");
        ctx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);

        const now = Date.now();

        for (const body of bodies) {
          // 只为非星际物质的天体绘制轨迹
          if (body.type !== "星际物质" && body.trail && body.trail.length > 0) {
            // 绘制整条轨迹路径
            ctx.beginPath();

            // 获取第一个点的屏幕坐标
            const firstPoint = body.trail[0];
            const screenX0 =
              (firstPoint.x - sun.x) * scale + trailCanvas.width / 2;
            const screenY0 =
              (firstPoint.y - sun.y) * scale + trailCanvas.height / 2;
            ctx.moveTo(screenX0, screenY0);

            // 连接所有轨迹点
            for (let i = 1; i < body.trail.length; i++) {
              const point = body.trail[i];
              const screenX = (point.x - sun.x) * scale + trailCanvas.width / 2;
              const screenY =
                (point.y - sun.y) * scale + trailCanvas.height / 2;
              ctx.lineTo(screenX, screenY);
            }

            // 最后连接到天体当前位置
            const currentX = (body.x - sun.x) * scale + trailCanvas.width / 2;
            const currentY = (body.y - sun.y) * scale + trailCanvas.height / 2;
            ctx.lineTo(currentX, currentY);

            // 设置渐变效果
            let gradient;
            if (body.trail.length > 1) {
              gradient = ctx.createLinearGradient(
                (body.trail[0].x - sun.x) * scale + trailCanvas.width / 2,
                (body.trail[0].y - sun.y) * scale + trailCanvas.height / 2,
                currentX,
                currentY
              );

              // 最早的点（最透明）
              gradient.addColorStop(
                0,
                `rgba(${Math.floor(body.color[0] * 255)}, ${Math.floor(
                  body.color[1] * 255
                )}, ${Math.floor(body.color[2] * 255)}, 0.1)`
              );
              // 最新的点（最不透明）
              gradient.addColorStop(
                1,
                `rgba(${Math.floor(body.color[0] * 255)}, ${Math.floor(
                  body.color[1] * 255
                )}, ${Math.floor(body.color[2] * 255)}, 0.8)`
              );

              ctx.strokeStyle = gradient;
            } else {
              // 如果只有一个点，就使用固定颜色
              ctx.strokeStyle = `rgba(${Math.floor(
                body.color[0] * 255
              )}, ${Math.floor(body.color[1] * 255)}, ${Math.floor(
                body.color[2] * 255
              )}, 0.5)`;
            }

            // 根据天体质量计算轨迹宽度，范围从2到8
            let lineWidth = 2;
            if (body.mass >= PLANET_THRESHOLD) {
              lineWidth = 3;
            }
            if (body.type >= GAS_GIANT_THRESHOLD) {
              lineWidth = 4;
            }
            ctx.lineWidth = lineWidth;
            ctx.stroke();
          }
        }
      }

      // 创建一个单独的2D canvas用于绘制轨迹
      const trailCanvas = document.createElement("canvas");
      trailCanvas.width = canvas.width;
      trailCanvas.height = canvas.height;
      trailCanvas.style.position = "absolute";
      trailCanvas.style.top = "0";
      trailCanvas.style.left = "0";
      trailCanvas.style.pointerEvents = "none";
      document.body.insertBefore(trailCanvas, labelCanvas); // 插入到标签 Canvas 之前

      // 创建一个单独的2D canvas用于绘制爆炸效果
      const explosionCanvas = document.createElement("canvas");
      explosionCanvas.width = canvas.width;
      explosionCanvas.height = canvas.height;
      explosionCanvas.style.position = "absolute";
      explosionCanvas.style.top = "0";
      explosionCanvas.style.left = "0";
      explosionCanvas.style.pointerEvents = "none";
      document.body.insertBefore(explosionCanvas, trailCanvas); // 插入到轨迹Canvas之前
      // 确保在窗口大小改变时更新标签canvas的尺寸
      window.addEventListener("resize", () => {
        labelCanvas.width = canvas.width;
        labelCanvas.height = canvas.height;
        trailCanvas.width = canvas.width;
        trailCanvas.height = canvas.height;
        explosionCanvas.width = canvas.width; // 添加这行
        explosionCanvas.height = canvas.height; // 添加这行
      });
      function calculateCircularVelocity(mass, distance) {
        return Math.sqrt((G * mass) / distance);
      }
      // 生成随机星际物质
      function spawnMatterReal() {
        // 在太阳周围随机位置生成
        const mass = Math.random() * 0.8 + 0.2;
        const distance = Math.random() * 300 + 50 + sun.radius;
        const angle = Math.random() * Math.PI * 2;
        const x = sun.x + Math.cos(angle) * distance;
        const y = sun.y + Math.sin(angle) * distance;
        // 计算初速度（使其围绕太阳旋转）
        const velo = calculateCircularVelocity(sun.mass, distance);
        const orbitSpeed = velo * 0.95 + Math.random() * velo * 0.1;
        const vx = -Math.sin(angle) * orbitSpeed;
        const vy = Math.cos(angle) * orbitSpeed;
        // 随机颜色
        const color = [
          0.5 + Math.random() * 0.5,
          0.5 + Math.random() * 0.5,
          0.5 + Math.random() * 0.5,
        ];
        const newMatter = new CelestialBody(
          x,
          y,
          vx,
          vy,
          mass,
          color,
          "",
          "星际物质"
        );
        matter.push(newMatter);
      }
      function spawnMatter() {
        if (bodies.length > MAX_OBJECTS) {
          return;
        }

        if (gameTime >= SUN_DEATH_TIME) {
          // 太阳爆炸
          return;
        }

        const now = Date.now();

        // 直接使用速度因子计算当前间隔
        // 速度因子越高，间隔越短，生成越快
        const currentInterval = baseSpawnInterval / (spawnSpeedFactor / 20);

        // 计算生成概率
        const elapsedTime = now - lastMatterSpawn;
        const spawnProbability = elapsedTime / currentInterval;

        // 使用概率决定是否生成物质
        if (Math.random() < spawnProbability && gameRunning) {
          lastMatterSpawn = now;

          // 根据速度因子动态调整一次生成的数量
          const speedRatio = spawnSpeedFactor / 20;
          const baseCount = Math.min(
            8,
            Math.max(1, Math.floor(Math.sqrt(speedRatio)))
          );
          const num = Math.floor(Math.random() * baseCount) + 1;

          for (let i = 0; i < num; i++) {
            spawnMatterReal();
          }
        }
      }

      // 处理碰撞
      function handleCollision(body1, body2) {
        if (body1.type == "sun") {
          return body1;
        }
        if (body2.type == "sun") {
          return body2;
        }
        // 确定哪个天体更大
        let larger, smaller;
        if (body1.mass >= body2.mass) {
          larger = body1;
          smaller = body2;
        } else {
          larger = body2;
          smaller = body1;
        }
        // 合并后的质量
        const totalMass = larger.mass + smaller.mass;
        const addedMass = mergeScaler(larger.mass) * smaller.mass;
        const mergedMass = larger.mass + addedMass;
        // 动量守恒计算新速度

        if (smaller.type != "星际物质") {
          larger.vx =
            (larger.vx * larger.mass + smaller.vx * addedMass) / mergedMass;
          larger.vy =
            (larger.vy * larger.mass + smaller.vy * addedMass) / mergedMass;
        }

        // 更新质量和半径
        larger.mass = mergedMass;
        larger.radius = Math.pow(mergedMass, RADIUS_FACTOR) * SCALE_FACTOR;
        // 更新类型和名称
        larger.updateTypeAndName();
        return larger;
      }
      // 更新游戏状态
      function updateGame(dt) {
        if (!gameRunning) return;
        // 生成新物质
        spawnMatter();
        // 更新太阳状态
        updateSun();
        // 更新所有天体
        for (let i = 0; i < bodies.length; i++) {
          bodies[i].update(dt);
          const sunDist = Math.sqrt(
            Math.pow(bodies[i].x - sun.x, 2) + Math.pow(bodies[i].y - sun.y, 2)
          );
          if (
            bodies[i].type != "sun" &&
            (sunDist >= PURGE_DISTANCE ||
              sunDist < bodies[i].radius + sun.radius)
          ) {
            explosions.push(
              new Explosion(
                bodies[i].x,
                bodies[i].y,
                bodies[i].color,
                bodies[i].radius
              )
            );
            bodies.splice(i, 1);
            i--;
            continue;
          }

          if (bodies[i])
            if (mouseDown) {
              // 应用玩家引力场
              bodies[i].applyPlayerGravity(
                mouseX,
                mouseY,
                gravityStrength,
                false,
                dt
              );
            }
          // 应用玩家斥力场
          if (rightMouseDown) {
            bodies[i].applyPlayerGravity(
              mouseX,
              mouseY,
              gravityStrength,
              true,
              dt
            );
          }
          // 天体之间的引力和碰撞
          for (let j = i + 1; j < bodies.length; j++) {
            if (bodies[i].type !== "sun" && bodies[j].type !== "sun") {
              const collision = bodies[i].applyGravity(bodies[j], dt);
              if (collision) {
                const merged = handleCollision(bodies[i], bodies[j]);
                if (merged === bodies[i]) {
                  // 添加爆炸效果 - 被消灭的是bodies[j]
                  explosions.push(
                    new Explosion(
                      bodies[j].x,
                      bodies[j].y,
                      bodies[j].color,
                      bodies[j].radius
                    )
                  );
                  bodies.splice(j, 1);
                  j--;
                } else {
                  // 添加爆炸效果 - 被消灭的是bodies[i]
                  explosions.push(
                    new Explosion(
                      bodies[i].x,
                      bodies[i].y,
                      bodies[i].color,
                      bodies[i].radius
                    )
                  );
                  bodies.splice(i, 1);
                  i--;
                  break;
                }
              }
            }
          }

          // 星际物质的引力和碰撞
          if (bodies[i].type !== "sun") {
            for (let j = 0; j < matter.length; j++) {
              const collision = bodies[i].applyGravity(matter[j], dt);
              if (collision) {
                handleCollision(bodies[i], matter[j]);
                matter.splice(j, 1);
                j--;
              }
            }
            const collisionWithSun = bodies[i].applyGravity(sun, dt);
            if (collisionWithSun) {
              handleCollision(sun, bodies[i]);
              matter.splice(i, 1);
              i--;
              continue;
            }
          }
        }
        // 星际物质之间的碰撞
        for (let i = 0; i < matter.length; i++) {
          matter[i].update(dt);

          const sunDist = Math.sqrt(
            Math.pow(matter[i].x - sun.x, 2) + Math.pow(matter[i].y - sun.y, 2)
          );
          if (sunDist >= PURGE_DISTANCE || sunDist < sun.radius) {
            matter.splice(i, 1);
            i--;
            continue;
          }

          // 应用玩家引力场
          if (mouseDown) {
            matter[i].applyPlayerGravity(
              mouseX,
              mouseY,
              gravityStrength,
              false,
              dt
            );
          }
          // 应用玩家斥力场
          if (rightMouseDown) {
            matter[i].applyPlayerGravity(
              mouseX,
              mouseY,
              gravityStrength,
              true,
              dt
            );
          }
          // 与太阳的引力和碰撞
          const collisionWithSun = matter[i].applyGravity(sun, dt);
          if (collisionWithSun) {
            handleCollision(sun, matter[i]);
            matter.splice(i, 1);
            i--;
            continue;
          }
          // 星际物质之间的碰撞
          for (let j = i + 1; j < matter.length; j++) {
            const dist = Math.sqrt(
              Math.pow(matter[i].x - matter[j].x, 2) +
                Math.pow(matter[i].y - matter[j].y, 2)
            );
            if (dist < 3.5) {
              const merged = handleCollision(matter[i], matter[j]);
              // 如果合并后的质量达到小行星阈值，将其移至bodies数组
              if (merged.mass >= ASTEROID_THRESHOLD) {
                bodies.push(merged);
                matter.splice(matter.indexOf(merged), 1);
              }
              if (merged === matter[i]) {
                matter.splice(j, 1);
                j--;
              } else {
                matter.splice(i, 1);
                i--;
                break;
              }
            }
          }
        }
        // 更新UI
        updateUI();
      }
      // 更新太阳状态
      function updateSun() {
        // 根据游戏时间更新太阳外观
        sun.x = 0.0;
        sun.y = 0.0;
        sun.mass = SUN_MASS;
        const SUN_BASE_RADIUS = 50;
        const SUN_MAX_RADIUS = 180;
        const SUPERNOVA_RADIUS = 1500;
        const MIN_SHRINK_RADIUS = 5; // 收缩到最小的半径

        if (gameTime >= GAME_DURATION - SUN_EXPLODE_TIME) {
          // 爆炸阶段
          const progress =
            (gameTime - (GAME_DURATION - SUN_EXPLODE_TIME)) / SUN_EXPLODE_TIME;
          sun.radius =
            MIN_SHRINK_RADIUS +
            (SUPERNOVA_RADIUS - MIN_SHRINK_RADIUS) * progress;

          // 青蓝色，逐渐变得透明
          // [R, G, B, A] 其中 A 是透明度，从1（不透明）到0（完全透明）
          sun.color = [0.2, 0.7, 1.0, 1.0 - progress * 1.0]; // 青蓝色，逐渐透明
        } else if (
          gameTime >= SUN_DEATH_TIME &&
          gameTime < SUN_DEATH_TIME + SUN_SHRINK_TIME
        ) {
          // 收缩阶段
          const progress = (gameTime - SUN_DEATH_TIME) / SUN_SHRINK_TIME;
          sun.radius =
            SUN_MAX_RADIUS - (SUN_MAX_RADIUS - MIN_SHRINK_RADIUS) * progress;

          // 从红色逐渐变蓝
          sun.color = [
            1.0 - 0.8 * progress, // 红色减少
            0.15 + 0.55 * progress, // 绿色增加
            0.1 + 0.9 * progress, // 蓝色增加
          ]; // 从红色到青蓝色
        } else if (gameTime >= SUN_DEATH_TIME) {
          // stale, do nothing
        } else if (gameTime >= RED_GIANT_TIME) {
          // 红巨星阶段
          const progress =
            (gameTime - RED_GIANT_TIME) / (GAME_DURATION - RED_GIANT_TIME);
          sun.radius = SUN_MAX_RADIUS;
          sun.color = [1.0, 0.15, 0.1]; // 红色
        } else if (gameTime >= SUN_EXPANSION_TIME) {
          // 膨胀阶段
          const progress =
            (gameTime - SUN_EXPANSION_TIME) /
            (RED_GIANT_TIME - SUN_EXPANSION_TIME);
          sun.radius =
            SUN_BASE_RADIUS + (SUN_MAX_RADIUS - SUN_BASE_RADIUS) * progress;
          sun.color = [1.0, 0.6 - 0.45 * progress, 0.0]; // 从黄橙色到红橙色
        } else {
          // 正常阶段
          const progress = gameTime / SUN_EXPANSION_TIME;
          sun.radius = SUN_BASE_RADIUS;
          sun.color = [1.0, 0.9 - 0.3 * progress, 0.0]; // 从黄色到黄橙色
        }
        // 游戏结束检查
        if (gameTime >= GAME_DURATION) {
          gameOver();
        }
      }
      // 游戏结束
      function gameOver() {
        gameRunning = false;
        document.getElementById("gameOver").style.display = "block";
      }
      // 更新UI
      function updateUI() {
        // 更新引力强度显示
        document.getElementById("gravityValue").textContent = gravityStrength;
        // 更新星体数量
        document.getElementById("bodyCount").textContent = bodies.length;
        document.getElementById("totalBodyCount").textContent = bodyIdCounter;

        const displayValue = (spawnSpeedFactor / 20).toFixed(1) + "x";
        document.getElementById("spawnSpeedValue").textContent = displayValue;
        // 找到最大的行星
        let largestPlanet = null;
        for (const body of bodies) {
          if (body.type !== "sun" && body.mass >= ASTEROID_THRESHOLD) {
            if (!largestPlanet || body.mass > largestPlanet.mass) {
              largestPlanet = body;
            }
          }
        }
        // 更新最大行星显示
        if (largestPlanet) {
          document.getElementById("largestPlanet").textContent = `${
            largestPlanet.name
          } (质量: ${Math.round(largestPlanet.mass)})`;
        } else {
          document.getElementById("largestPlanet").textContent = "无";
        }
        // 更新游戏时间
        const minutes = Math.floor(gameTime / 60);
        const seconds = Math.floor(gameTime % 60);
        document.getElementById("gameTime").textContent = `${minutes
          .toString()
          .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      }
      // 事件监听器
      canvas.addEventListener("mousemove", (e) => {
        const worldX = (e.clientX - canvas.width / 2) / scale + sun.x;
        const worldY = (e.clientY - canvas.height / 2) / scale + sun.y;
        mouseX = worldX;
        mouseY = worldY;
      });

      canvas.addEventListener("mousedown", (e) => {
        const worldX = (e.clientX - canvas.width / 2) / scale + sun.x;
        const worldY = (e.clientY - canvas.height / 2) / scale + sun.y;

        if (e.button === 0 || e.button === 2) {
          mouseX = worldX;
          mouseY = worldY;
        }

        if (e.button === 0) {
          mouseDown = true;
          console.log("点击位置: (" + worldX + ", " + worldY + ")");
        } else if (e.button === 2) {
          rightMouseDown = true;

          // 添加调试信息
          console.log("点击位置:", worldX, worldY);
          console.log("天体数量:", bodies.length);

          for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            if (body.type === "sun") continue;
            const dist = Math.sqrt(
              Math.pow(body.x - worldX, 2) + Math.pow(body.y - worldY, 2)
            );
            if (dist < body.radius) {
              console.log("点击到天体:", body.name);
              // 分裂天体
              const fragments = body.split();
              if (fragments.length > 1) {
                // 移除原天体
                bodies.splice(i, 1);
                // 添加碎片
                for (const fragment of fragments) {
                  if (fragment.mass >= ASTEROID_THRESHOLD) {
                    bodies.push(fragment);
                  } else {
                    matter.push(fragment);
                  }
                }
              }
              break;
            }
          }
        }
      });

      canvas.addEventListener("mouseup", (e) => {
        if (e.button === 0) {
          mouseDown = false;
        } else if (e.button === 2) {
          rightMouseDown = false;
        }
      });
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
      // 滚轮缩放
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        if (e.deltaY < 0) {
          // 放大
          scale *= 1.1;
        } else {
          // 缩小
          scale *= 0.9;
        }
        // 限制缩放范围
        scale = Math.max(0.1, Math.min(scale, 5.0));
      });
      // 引力强度滑块
      document
        .getElementById("gravityStrength")
        .addEventListener("input", (e) => {
          gravityStrength = parseInt(e.target.value);
          document.getElementById("gravityValue").textContent = gravityStrength;
        });
      // 修改滑块事件监听器
      document.getElementById("spawnSpeed").addEventListener("input", (e) => {
        const sliderValue = parseInt(e.target.value);

        // 使用非线性映射使控制更加平滑
        if (sliderValue <= 100) {
          // 1-100范围内线性增长
          spawnSpeedFactor = sliderValue;
        } else if (sliderValue <= 300) {
          // 100-300范围内中等增长
          spawnSpeedFactor = 100 + (sliderValue - 100) * 2;
        } else if (sliderValue <= 600) {
          // 300-600范围内快速增长
          spawnSpeedFactor = 500 + (sliderValue - 300) * 5;
        } else {
          // 600以上范围快速增长
          spawnSpeedFactor = 2000 + (sliderValue - 600) * 10;
        }

        // 更新显示值，显示为相对于初始值的倍数
        const displayValue = (spawnSpeedFactor / 20).toFixed(1) + "x";
        document.getElementById("spawnSpeedValue").textContent = displayValue;
      });
      // 重新开始按钮
      document.getElementById("restartButton").addEventListener("click", () => {
        // 重置游戏状态
        gameTime = 0;
        gameRunning = true;
        bodies = [sun]; // 只保留太阳
        matter = [];
        // 重置太阳
        sun.radius = 30;
        explosions = []; // 清空爆炸效果
        sun.trail = []; // 清除太阳轨迹
        bodyIdCounter = 0;
        sun.color = [1.0, 0.9, 0.0];
        // 隐藏游戏结束界面
        document.getElementById("gameOver").style.display = "none";
      });
      // 游戏循环
      let lastTime = 0;

      function gameLoop(currentTime) {
        if (lastTime === 0) {
          lastTime = currentTime;
        }
        const deltaTime = ((currentTime - lastTime) / 1000) * TIME_SCALE; // 转换为秒
        lastTime = currentTime;
        if (gameRunning) {
          gameTime += deltaTime / TIME_SCALE;
        }
        // 更新游戏状态
        updateGame(deltaTime);
        // 更新缓冲区并绘制
        const count = updateBuffers();
        drawScene(count);
        // 继续循环
        requestAnimationFrame(gameLoop);
      }
      // 开始游戏循环
      requestAnimationFrame(gameLoop);
    </script>
  </body>
</html>
